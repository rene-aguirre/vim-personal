#personal python snippets
snippet sb
	#!/usr/bin/env python
	# -*- coding: `printf("%s",&fileencoding == "" ? (&encoding == "latin1" ? "latin-1" : &encoding) : (&fileencoding == "latin1" ? "latin-1" : &fileencoding))` -*-
	${2}
#
snippet doc
	"""${1}"""${2}
#
snippet property set/get/del property
	@apply
	def ${1:property_name}():
		doc = """The $1 property"""
		def fset(self, ${3:value}):
			self._${2:$1} = ${4:$3}
		
		def fget(self):
			return ${5:self._$2}
		
		def fdel(self):
			del self._$2
		return property(**locals())
	${6}
#
snippet decorator
	def ${1:decorator_name}(func):
		"""The $1 decorator"""
		def ${2:new_decorator}(*args, **kwargs):
			#${3:doing something useful with decorated function}
			${4:return func(*args, **kwargs)}

		# be a well-behaved decorator.
		$2.__name__ = func.__name__
		$2.__doc__ = func.__doc__
		$2.__dict__.update(func.__dict__)
		
		return $2
	${5}
#
snippet singleton
	class ${1:SingletonClassName}(${2:object}):
		"Singleton $1 class"
		__single = None # true singleton instance
		
		def __init__(self, ${3:}*args, **kwargs):
			${5:pass}
		
		def __new__(classtype, $3*args, **kwargs):
			# Check to see if a __single exists already for this class
			# Compare class types instead of just looking for None so
			# that subclasses will create their own __single objects
			if classtype != type(classtype.__single):
				classtype.__single = super($1, \
						$2).__new__($2, ${4:$3*args, **kwargs})
			return classtype.__single
#
# New Class
snippet class super class
	class ${1:ClassName}(${2}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:*args, **kw}):
			super($1, self).__init__(${5:$4})
			${6}
#
snippet class normal class
	class ${1:ClassName}(${2:}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:}):
			$2.__init__(${5:$4})
			${6}
#
#default template for a module
snippet module
	#!/usr/bin/env python
	# -*- coding: `printf("%s",&fileencoding == "" ? (&encoding == "latin1" ? "latin-1" : &encoding) : (&fileencoding == "latin1" ? "latin-1" : &fileencoding))` -*-
	import logging
	
	#version string
	__version__ = "0.0.1"

	def test_messages():
		#change verbosity to test the messages
		logging.debug("This is a debug message")
		logging.info("This is an info message")
		logging.warn("This is a warning message")
		logging.error("This is an error message")
		try:
			raise Exception("This is an exception (error) message")
		except Exception:
			logging.exception("This is an error message with traceback info (logging.exception):")
	
	if __name__ == '__main__':
		import sys
		import optparse
	
		def main(options, args):
			"${1:A simple script}"
			# this doc string is used for the script description
			# give a brief overview of your program
			if not args:
				sys.stderr.write("No arguments!\n")
			elif len(args) > 1:
				print "A single script argument:", args[0]
			else:
				print "These are the arguments:", args
			print '\n',
			${2:#write, here you're code}
			test_messages()
			# return error level
			return 0
	
		option_parser = optparse.OptionParser(version = "%prog " + __version__)
		# part of the usage text (--help), located before the options list
		option_parser.description = main.__doc__
		# add our options
		option_parser.add_option('-v', '--verbose', action='store', type="string", dest='verbose', 
						help="set verbosity (critical, error, warning, info, debug), defaults\
								to warning")
		# parse the arguments (defaults to parsing sys.argv)
		options, arg_list = option_parser.parse_args()
	
		logging_level = logging.WARNING
		verbosity = {
			'debug': logging.DEBUG,
			'info': logging.INFO,
			'warning': logging.WARNING,
			'error': logging.ERROR,
			'critical': logging.CRITICAL
		}
		if options.verbose:
			if options.verbose.lower() in verbosity:
				logging_level = verbosity.get(options.verbose.lower())
			else:
				option_parser.error("I don't know about '%s' verbosity" % options.verbose)
		# add further options validation
	
		# basic logging configuration
		logging.basicConfig(level=logging_level)
		
		sys.exit( main(options, arg_list) )
	 
#

